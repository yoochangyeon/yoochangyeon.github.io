---
publishDate: 2025-01-14T15:00:00Z
updateDate: 2025-01-14T15:00:00Z
author: "ìœ ì°½ì—°"
title: "Lambda@Edge ì´ë¯¸ì§€ ìµœì í™”: ì‘ë‹µì‹œê°„ 90% ê°œì„  (20ì´ˆâ†’2ì´ˆ)"
excerpt: "AWS Lambda@Edgeë¡œ AVIF ì´ë¯¸ì§€ ë³€í™˜ ì„±ëŠ¥ ë³‘ëª©ì„ í•´ê²°í•œ ì‹¤ì „ ê²½í—˜. SQS ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ë¡œ ì‘ë‹µ ì‹œê°„ì„ 20ì´ˆì—ì„œ 2ì´ˆë¡œ ë‹¨ì¶•í•œ ë°©ë²•ì„ ì½”ë“œì™€ í•¨ê»˜ ê³µìœ í•©ë‹ˆë‹¤."
description: "AWS Lambda@Edgeì™€ CloudFrontë¡œ ì‹¤ì‹œê°„ ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì§• ì‹œìŠ¤í…œì„ êµ¬ì¶•í•˜ê³ , AVIF ë³€í™˜ì˜ ì„±ëŠ¥ ë³‘ëª© í˜„ìƒì„ SQS ì´ë²¤íŠ¸ ì•„í‚¤í…ì²˜ë¡œ í•´ê²°í–ˆìŠµë‹ˆë‹¤. ì‘ë‹µ ì‹œê°„ì„ 90% ê°œì„ í•œ êµ¬ì²´ì ì¸ ë°©ë²•ê³¼ ì½”ë“œë¥¼ ê³µìœ í•©ë‹ˆë‹¤."
# TODO: ì´ë¯¸ì§€ ìµœì í™” ê¶Œì¥ì‚¬í•­
# 1. Unsplash ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì—¬ /public/images/blog/ ì— ì €ì¥
# 2. WebP í¬ë§·ìœ¼ë¡œ ë³€í™˜ (squoosh.app ë˜ëŠ” sharp í™œìš©)
# 3. íŒŒì¼ëª…: lambda-edge-optimization.webp
# 4. image ì†ì„±ì„ "/images/blog/lambda-edge-optimization.webp"ë¡œ ë³€ê²½
image: "https://images.unsplash.com/photo-1451187580459-43490279c0fa?w=1200&h=630&fit=crop"
imageAlt: "AWS Lambda@Edge ì•„í‚¤í…ì²˜ ë‹¤ì´ì–´ê·¸ë¨ - CloudFront CDNì—ì„œ Lambda í•¨ìˆ˜ë¥¼ í†µí•œ ì´ë¯¸ì§€ ìµœì í™” í”„ë¡œì„¸ìŠ¤"
category: "AWS"
tags: ["aws", "lambda", "cloudfront", "image-optimization", "performance", "serverless"]
keywords: ["Lambda@Edge", "ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì§•", "AVIF ìµœì í™”", "WebP ë³€í™˜", "CloudFront CDN", "SQS ì´ë²¤íŠ¸", "ì´ë¯¸ì§€ ìµœì í™”", "AWS ì„±ëŠ¥ ê°œì„ ", "Sharp ë¼ì´ë¸ŒëŸ¬ë¦¬", "ì„œë²„ë¦¬ìŠ¤ ì•„í‚¤í…ì²˜"]
draft: false
---

## ë°°ê²½

ìµœê·¼ ì§„í–‰í•˜ê³  ìˆëŠ” í”„ë¡œì íŠ¸ì—ì„œ **ì›¹ í˜ì´ì§€ì˜ ë¡œë”© ì†ë„ê°€ SEO ìˆœìœ„ì— ë¯¸ì¹˜ëŠ” ì˜í–¥**ì´ ì»¤ì§€ë©´ì„œ, ì´ë¯¸ì§€ ìµœì í™”ê°€ í•„ìš”í–ˆìŠµë‹ˆë‹¤.

### ì„ íƒí•œ ì•„í‚¤í…ì²˜

**Lambda@Edge**ì™€ **CloudFront**ë¥¼ í™œìš©í•˜ì—¬ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„í•˜ê¸°ë¡œ í–ˆìŠµë‹ˆë‹¤:

- S3ì— ì €ì¥ëœ ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ë¦¬ì‚¬ì´ì§•
- í´ë¼ì´ì–¸íŠ¸ì˜ `Accept` í—¤ë”ë¥¼ ì°¸ê³ í•˜ì—¬ ìµœì ì˜ í¬ë§· ì „ë‹¬
  - AVIF (ìµœê³  ì••ì¶•ë¥ )
  - WebP (ë„ë¦¬ ì§€ì›)
  - ì›ë³¸ í¬ë§· (fallback)

ì´ ê¸€ì—ì„œëŠ” ê¸°ì¡´ ì½”ë“œë¥¼ ë°”íƒ•ìœ¼ë¡œ ê°œì„  ì‚¬í•­ê³¼ ê·¸ ê³¼ì •ì—ì„œ ë°œìƒí•œ ë¬¸ì œ, ê·¸ë¦¬ê³  í•´ê²° ê³¼ì •ì„ ì†Œê°œí•©ë‹ˆë‹¤.

---

## 1. ê¸°ì¡´ ì½”ë“œ ë¶„ì„ ë° ê°œì„  í•„ìš”ì„±

### ì´ˆê¸° êµ¬í˜„

ê¸°ì¡´ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì€ íë¦„ìœ¼ë¡œ ë™ì‘í–ˆìŠµë‹ˆë‹¤:

1. **S3ì—ì„œ ì´ë¯¸ì§€ ë¡œë“œ**: `getFileAsBuffer` í•¨ìˆ˜ë¡œ ìŠ¤íŠ¸ë¦¼ì„ Bufferë¡œ ë³€í™˜
2. **ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì§•**: sharp ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ í¬ê¸° ì¡°ì •
3. **WebP ë³€í™˜**: ë³€í™˜ í›„ Base64 ì¸ì½”ë”©í•˜ì—¬ ë°˜í™˜
4. **í¬ê¸° ì œí•œ**: ê°€ë¡œ ì‚¬ì´ì¦ˆê°€ 856px ì´ˆê³¼ ì‹œ ìë™ ì¶•ì†Œ

```typescript
const convertToWebPAndBase64 = async (
  buff: Buffer,
  w?: number,
  h?: number,
  quality: number = 70
): Promise<string> => {
  if (quality <= 10) throw new Error("quality is too low");

  try {
    let result = sharp(buff);
    const metadata = await result.metadata();
    const originalWidth = metadata.width || 0;

    if (w && h) {
      result = result.resize(w, h, { withoutEnlargement: true });
    } else if (originalWidth > 856) {
      result = result.resize({ width: 856 });
    }

    const webpBuffer = await result.webp({ quality }).toBuffer();

    if (webpBuffer.byteLength > MB) {
      return await convertToWebPAndBase64(buff, w, h, Math.floor(quality / 2));
    }

    return webpBuffer.toString("base64");
  } catch (error) {
    throw error;
  }
};
```

### ë¬¸ì œì 

ê¸°ì¡´ ì½”ë“œì—ì„œëŠ” ì´ë¯¸ì§€ì˜ ê°€ë¡œ ì‚¬ì´ì¦ˆê°€ 856px ì´ˆê³¼ ì‹œ ë‹¨ìˆœíˆ 856pxë¡œ ì¤„ì—¬ì£¼ë„ë¡ ë˜ì–´ ìˆì—ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ **ì´ë¯¸ì§€ ë¹„ìœ¨ì´ ê³ ë ¤ë˜ì§€ ì•Šì•„** ì™œê³¡ë  ê°€ëŠ¥ì„±ì´ ìˆì—ˆìŠµë‹ˆë‹¤.

### ê°œì„  ë°©ì•ˆ

Sharpì˜ `resize` ì˜µì…˜ ì¤‘ **`fit: 'inside'`**ë¥¼ í™œìš©í•˜ë©´:
- ì´ë¯¸ì§€ ë¹„ìœ¨ì€ ìœ ì§€í•˜ë˜
- ì§€ì •ëœ ì˜ì—­ ì•ˆì— ë§ê²Œ ë¦¬ì‚¬ì´ì§• ê°€ëŠ¥

```typescript
const convertToWebPAndBase64 = async (
  buff: Buffer,
  w?: number,
  h?: number,
  quality: number = 70
): Promise<string> => {
  if (quality <= 10) throw new Error("quality is too low");

  try {
    let result = sharp(buff);
    const metadata = await result.metadata();
    const originalWidth = metadata.width || 0;

    // width í˜¹ì€ heightê°€ ìš”ì²­ë˜ì—ˆìœ¼ë©´ í•´ë‹¹ ê°’ìœ¼ë¡œ ë¦¬ì‚¬ì´ì§•
    if (w || h) {
      const resizeOptions = {
        fit: 'inside',            // ë¹„ìœ¨ì— ë§ì¶° ì¡°ì •í•˜ê³  ì´ë¯¸ì§€ë¥¼ ìë¥´ì§€ ì•ŠìŒ
        withoutEnlargement: true, // ì›ë³¸ë³´ë‹¤ í¬ê²Œ ëŠ˜ë¦¬ì§€ ì•ŠìŒ
      };
      result = result.resize({ width: w, height: h, ...resizeOptions });
    } else if (originalWidth > 856) {
      // ì›ë³¸ ì´ë¯¸ì§€ì˜ ê°€ë¡œ ì‚¬ì´ì¦ˆê°€ 856px ì´ˆê³¼ë©´ 856pxë¡œ ì¤„ì´ë˜, ë¹„ìœ¨ ìœ ì§€
      result = result.resize({
        width: 856,
        fit: 'inside',
        withoutEnlargement: true
      });
    }

    const webpBuffer = await result.webp({ quality }).toBuffer();

    if (webpBuffer.byteLength > MB) {
      return await convertToWebPAndBase64(buff, w, h, Math.floor(quality / 2));
    }

    return webpBuffer.toString("base64");
  } catch (error) {
    throw error;
  }
};
```

---

## 2. AVIF ë³€í™˜ì˜ ì„±ëŠ¥ ë¬¸ì œ

### ë¬¸ì œ ë°œìƒ

ì‹¤ì œ êµ¬í˜„ ê³¼ì •ì—ì„œ **AVIF í¬ë§· ë³€í™˜ì„ ì¶”ê°€**í•˜ë ¤ í–ˆì§€ë§Œ, ì‹¬ê°í•œ ì„±ëŠ¥ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:

- âœ… **WebP ë³€í™˜**: ë¹„êµì  ë¹ ë¥´ê²Œ ìˆ˜í–‰ (~1-2ì´ˆ)
- âŒ **AVIF ë³€í™˜**: ì´ë¯¸ì§€ í¬ê¸°ì— ë”°ë¼ **20ì´ˆ ì´ìƒ** ì†Œìš”

### ì˜í–¥

Lambda@Edgeì—ì„œ ëª¨ë“  ì´ë¯¸ì§€ ìš”ì²­ ì‹œ ì‹¤ì‹œê°„ìœ¼ë¡œ AVIF ë³€í™˜ì„ ìˆ˜í–‰í•˜ë©´:

1. **ë³€í™˜ ì‹œê°„ì´ ê¸¸ì–´ì§**ì— ë”°ë¼ í˜ì´ì§€ ë¡œë”© ì†ë„ì— ì•…ì˜í–¥
2. í´ë¼ì´ì–¸íŠ¸ì˜ `Accept` í—¤ë”ì— AVIFê°€ í¬í•¨ëœ ê²½ìš°, **ì´ë¯¸ì§€ê°€ ì œëŒ€ë¡œ ëœ¨ì§€ ì•ŠëŠ” ë¬¸ì œ** ë°œìƒ
3. Lambda ì‹¤í–‰ ì‹œê°„ ì¦ê°€ë¡œ ì¸í•œ **ë¹„ìš© ì¦ê°€**

### ì¸¡ì • ê²°ê³¼

| ì´ë¯¸ì§€ í¬ê¸° | WebP ë³€í™˜ | AVIF ë³€í™˜ |
|------------|----------|----------|
| 500KB      | ~1.2ì´ˆ   | ~8ì´ˆ     |
| 1MB        | ~2.1ì´ˆ   | ~15ì´ˆ    |
| 2MB        | ~3.5ì´ˆ   | ~25ì´ˆ    |

---

## 3. í•´ê²°ì±…: ë°±ê·¸ë¼ìš´ë“œ ë³€í™˜ ì²˜ë¦¬

### ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜

ì›ë³¸ ì´ë¯¸ì§€ëŠ” S3ì— ê·¸ëŒ€ë¡œ ì €ì¥í•˜ê³ , **AVIF ë³€í™˜ì€ ë³„ë„ì˜ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…**ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ë°©ì‹ì„ ì±„íƒí–ˆìŠµë‹ˆë‹¤.

**SQS**ì™€ **ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜**ë¥¼ ë„ì…í•˜ì—¬:
- ì´ë¯¸ì§€ê°€ ì—…ë¡œë“œë˜ë©´ ë³€í™˜ ì‘ì—… ì´ë²¤íŠ¸ ë°œìƒ
- ë°±ê·¸ë¼ìš´ë“œì—ì„œ AVIF ë³€í™˜ ì‘ì—…ì´ ì§€ì†ì ìœ¼ë¡œ ì²˜ë¦¬

### êµ¬í˜„ íë¦„

```mermaid
graph LR
    A[í´ë¼ì´ì–¸íŠ¸ ìš”ì²­] --> B{AVIF íŒŒì¼<br/>ì¡´ì¬?}
    B -->|Yes| C[AVIF ë°˜í™˜]
    B -->|No| D[SQSì—<br/>ë³€í™˜ ì´ë²¤íŠ¸]
    D --> E[WebP ë°˜í™˜]
    D --> F[ë°±ê·¸ë¼ìš´ë“œ<br/>Lambda]
    F --> G[AVIF ë³€í™˜<br/>ë° ì €ì¥]
```

### ì£¼ìš” ë‹¨ê³„

1. **ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥**: S3ì— ì €ì¥ëœ ì›ë³¸ ë˜ëŠ” WebP ë³€í™˜ ì´ë¯¸ì§€ë¥¼ ë¹ ë¥´ê²Œ ë°˜í™˜
2. **ì´ë²¤íŠ¸ ë°œí–‰**: ì´ë¯¸ì§€ ì—…ë¡œë“œ ë˜ëŠ” ë³€í™˜ ìš”ì²­ ì‹œ SQSì— ì´ë²¤íŠ¸ ì „ì†¡
3. **ë°±ê·¸ë¼ìš´ë“œ í”„ë¡œì„¸ìŠ¤**: ë³„ë„ì˜ Lambdaê°€ SQS ë©”ì‹œì§€ë¥¼ êµ¬ë…í•˜ì—¬ AVIF ë³€í™˜ ìˆ˜í–‰
4. **ìºì‹œ ì—…ë°ì´íŠ¸**: ë³€í™˜ ì™„ë£Œ í›„ CloudFront ìºì‹œ ì—…ë°ì´íŠ¸

### ì¥ì 

- âœ… **ì´ë¯¸ì§€ ìš”ì²­ ì‘ë‹µ ì‹œê°„ ìµœì í™”**: ì¦‰ì‹œ WebP ë°˜í™˜
- âœ… **ë¬´ê±°ìš´ ì‘ì—… ë¹„ë™ê¸° ì²˜ë¦¬**: AVIF ë³€í™˜ì€ ë°±ê·¸ë¼ìš´ë“œì—ì„œ
- âœ… **ì‚¬ìš©ì ê²½í—˜ í–¥ìƒ**: ì´ë¯¸ì§€ ë¡œë”© ì§€ì—° ì—†ìŒ
- âœ… **ì ì§„ì  ìµœì í™”**: ì²« ìš”ì²­ì€ WebP, ì´í›„ AVIF ì œê³µ

---

## 4. ë°±ê·¸ë¼ìš´ë“œ ë³€í™˜ Lambda êµ¬í˜„

### SQS ë©”ì‹œì§€ ì²˜ë¦¬ Lambda

AVIF ë³€í™˜ì„ ë‹´ë‹¹í•˜ëŠ” ë°±ê·¸ë¼ìš´ë“œ Lambda í•¨ìˆ˜ì…ë‹ˆë‹¤.

```typescript
import { SQSHandler, SQSEvent } from 'aws-lambda';
import { S3Client, GetObjectCommand, PutObjectCommand } from '@aws-sdk/client-s3';
import sharp from 'sharp';
import { Readable } from 'stream';

const s3 = new S3Client({ region: 'ap-northeast-2' });

/**
 * S3ì—ì„œ ì§€ì •ëœ ê°ì²´ë¥¼ ì½ì–´ Bufferë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
 */
async function getFileBuffer(bucket: string, key: string): Promise<Buffer> {
  const command = new GetObjectCommand({ Bucket: bucket, Key: key });
  const data = await s3.send(command);

  return new Promise<Buffer>((resolve, reject) => {
    const chunks: Buffer[] = [];
    const stream = data.Body as Readable;
    stream.on('data', (chunk: Buffer) => chunks.push(chunk));
    stream.on('error', reject);
    stream.on('end', () => resolve(Buffer.concat(chunks)));
  });
}

/**
 * Bufferë¥¼ AVIF í¬ë§·ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
 */
async function convertToAvif(buffer: Buffer, quality: number = 50): Promise<Buffer> {
  return await sharp(buffer)
    .avif({ quality })
    .toBuffer();
}

/**
 * ë³€í™˜ëœ ì´ë¯¸ì§€ë¥¼ S3ì— ì €ì¥í•˜ëŠ” í•¨ìˆ˜
 */
async function putFileBuffer(
  bucket: string,
  key: string,
  buffer: Buffer,
  contentType: string
): Promise<void> {
  const command = new PutObjectCommand({
    Bucket: bucket,
    Key: key,
    Body: buffer,
    ContentType: contentType,
  });
  await s3.send(command);
}

/**
 * Lambda í•¸ë“¤ëŸ¬
 * SQS ë©”ì‹œì§€ ì´ë²¤íŠ¸ë¥¼ ë°›ì•„ ê° ë©”ì‹œì§€ì— ëŒ€í•´ ì´ë¯¸ì§€ ë³€í™˜ ì‘ì—…ì„ ìˆ˜í–‰
 *
 * ë©”ì‹œì§€ ì˜ˆì‹œ:
 * {
 *   "bucket": "media.example.com",
 *   "key": "images/sample.jpg",
 *   "targetBucket": "media.example.com",
 *   "quality": 50
 * }
 */
export const handler: SQSHandler = async (event: SQSEvent): Promise<void> => {
  for (const record of event.Records) {
    try {
      // ë©”ì‹œì§€ ë³¸ë¬¸ íŒŒì‹±
      const messageBody = JSON.parse(record.body);
      const { bucket, key, targetBucket, quality } = messageBody;

      console.log(`ì²˜ë¦¬ ì‹œì‘ - bucket: ${bucket}, key: ${key}`);

      // S3ì—ì„œ ì›ë³¸ ì´ë¯¸ì§€ ì½ê¸°
      const originalBuffer = await getFileBuffer(bucket, key);

      // AVIFë¡œ ë³€í™˜
      const avifBuffer = await convertToAvif(originalBuffer, quality);

      // ë³€í™˜ëœ ì´ë¯¸ì§€ì˜ S3 key ìƒì„±
      // ì˜ˆ: sample.jpg â†’ sample-avif.avif
      const newKey = key.replace(/\.(jpg|jpeg|png)$/i, '-avif.avif');

      // ë³€í™˜ ê²°ê³¼ë¥¼ S3ì— ì €ì¥
      await putFileBuffer(
        targetBucket || bucket,
        newKey,
        avifBuffer,
        'image/avif'
      );

      console.log(
        `ì´ë¯¸ì§€ ë³€í™˜ ì„±ê³µ: ${bucket}/${key} -> ${targetBucket || bucket}/${newKey}`
      );
    } catch (error) {
      console.error(`ë©”ì‹œì§€ ì²˜ë¦¬ ì‹¤íŒ¨ - ë©”ì‹œì§€ ID: ${record.messageId}`, error);
      // ì—ëŸ¬ ë°œìƒ ì‹œ Dead Letter Queue(DLQ)ë¡œ ì´ë™í•˜ê±°ë‚˜ ì¬ì²˜ë¦¬ ë¡œì§ ì¶”ê°€ ê°€ëŠ¥
    }
  }
};
```

---

## 5. Lambda@Edge í•¸ë“¤ëŸ¬ ê°œì„ 

ê¸°ì¡´ Lambda ì½”ë“œë¥¼ ê°œì„ í•˜ì—¬:

1. **AVIF íŒŒì¼ì´ S3ì— ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸**
2. ì¡´ì¬í•˜ë©´ AVIF ì´ë¯¸ì§€ ë°˜í™˜
3. ì—†ìœ¼ë©´ **SQSì— AVIF ë³€í™˜ ì´ë²¤íŠ¸ ì¶”ê°€** í›„ WebP ë°˜í™˜

```typescript
import {
  CloudFrontRequestCallback,
  CloudFrontRequestEvent,
  CloudFrontResponseCallback,
  CloudFrontResponseEvent,
  Context,
} from "aws-lambda";
import {
  GetObjectCommand,
  HeadObjectCommand,
  S3Client,
} from "@aws-sdk/client-s3";
import { SQSClient, SendMessageCommand } from "@aws-sdk/client-sqs";
import sharp from "sharp";
import { URLSearchParams } from "url";
import { Readable } from "stream";

const regex = new RegExp(/^\/\d+/);
const s3 = new S3Client({ region: "ap-northeast-2" });
const sqs = new SQSClient({ region: "ap-northeast-2" });
const QUEUE_URL = process.env.SQS_QUEUE_URL || "YOUR_SQS_QUEUE_URL";
const MB = 1 * 1024 * 1024;

/**
 * S3ì—ì„œ ê°ì²´ë¥¼ ì½ì–´ Bufferë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
 */
async function getFileAsBuffer(
  Bucket: string,
  Key: string
): Promise<Buffer | Error> {
  const params = { Bucket, Key };
  try {
    const streamToBuffer = (stream: any): Promise<Buffer> =>
      new Promise((resolve, reject) => {
        const chunks: Buffer[] = [];
        stream.on("data", (chunk: Buffer) => chunks.push(chunk));
        stream.on("error", reject);
        stream.on("end", () => resolve(Buffer.concat(chunks)));
      });

    const data = await s3.send(new GetObjectCommand(params));
    return await streamToBuffer(data.Body as Readable);
  } catch (err) {
    return err instanceof Error ? err : new Error("Unknown error occurred");
  }
}

/**
 * S3ì— í•´ë‹¹ ê°ì²´ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜ (HeadObject ì´ìš©)
 */
async function objectExists(Bucket: string, Key: string): Promise<boolean> {
  try {
    await s3.send(new HeadObjectCommand({ Bucket, Key }));
    return true;
  } catch (error: any) {
    if (error.name === 'NotFound' || error.$metadata?.httpStatusCode === 404) {
      return false;
    }
    throw error;
  }
}

/**
 * SQSì— ë©”ì‹œì§€ë¥¼ ì „ì†¡í•˜ëŠ” í•¨ìˆ˜
 */
async function sendSQSEvent(message: any): Promise<void> {
  const command = new SendMessageCommand({
    QueueUrl: QUEUE_URL,
    MessageBody: JSON.stringify(message),
  });
  await sqs.send(command);
}

/**
 * Lambda í•¸ë“¤ëŸ¬
 * 1. S3ì— AVIF íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
 *    - ì¡´ì¬í•˜ë©´ AVIF íŒŒì¼ì„ ì½ì–´ Base64ë¡œ ì¸ì½”ë”©í•˜ì—¬ ë°˜í™˜
 * 2. ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ SQSì— AVIF ë³€í™˜ ì´ë²¤íŠ¸ë¥¼ ì¶”ê°€í•˜ê³ ,
 *    WebP ë³€í™˜ ê²°ê³¼ë¥¼ ë°˜í™˜
 */
export async function handler(
  event: CloudFrontResponseEvent,
  context: Context,
  callback: CloudFrontResponseCallback
) {
  const request = event.Records[0].cf.request;
  let response = event.Records[0].cf.response;

  // 304 ì‘ë‹µ ì²˜ë¦¬
  if (response.status === "304") {
    if (!(response as any).body || (response as any).bodyEncoding !== "base64") {
      response.headers["cache-control"] = [
        { key: "Cache-Control", value: "public, max-age=86400" }
      ];
      callback(null, response);
      return;
    }
  }

  // Content-Type ê²€ì¦
  const contentTypeHeader = response.headers["content-type"]?.[0]?.value;
  if (
    !contentTypeHeader ||
    !["image/jpeg", "image/jpg", "image/png"].includes(
      contentTypeHeader.toLowerCase()
    )
  ) {
    callback(null, response);
    return;
  }

  // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° íŒŒì‹±
  const params = new URLSearchParams(request.querystring);
  let w, h;
  try {
    w = Number(params.get("w")) || undefined;
    h = Number(params.get("h")) || undefined;
  } catch (error) {
    callback(null, response);
    return;
  }

  if (!regex.test(request.uri)) {
    callback(null, response);
    return;
  }

  const bucket = "your-bucket-name";
  const key = request.uri.substring(1);
  // AVIF íŒŒì¼ëª… ìƒì„± (ì˜ˆ: sample.jpg â†’ sample-avif.avif)
  const avifKey = key.replace(/\.(jpg|jpeg|png)$/i, '-avif.avif');

  // 1. AVIF íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
  try {
    const avifExists = await objectExists(bucket, avifKey);
    if (avifExists) {
      // AVIF íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ í•´ë‹¹ íŒŒì¼ì„ ì½ì–´ì™€ ë°˜í™˜
      const avifBuffer = await getFileAsBuffer(bucket, avifKey);
      if (avifBuffer instanceof Error) {
        throw avifBuffer;
      }
      response.headers["content-type"] = [
        { key: "Content-Type", value: "image/avif" }
      ];
      response.headers["cache-control"] = [
        { key: "Cache-Control", value: "public, max-age=86400" }
      ];
      callback(null, {
        ...response,
        body: (avifBuffer as Buffer).toString("base64"),
        bodyEncoding: "base64"
      });
      return;
    }
  } catch (error) {
    console.error("AVIF íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸ ì¤‘ ì—ëŸ¬ ë°œìƒ", error);
  }

  // 2. AVIF íŒŒì¼ì´ ì—†ìœ¼ë©´ SQSì— ë³€í™˜ ì´ë²¤íŠ¸ ì „ì†¡
  try {
    const sqsMessage = {
      bucket,
      key,
      quality: 50
    };
    await sendSQSEvent(sqsMessage);
    console.log("SQSì— AVIF ë³€í™˜ ì´ë²¤íŠ¸ ì „ì†¡ ì™„ë£Œ", sqsMessage);
  } catch (error) {
    console.error("SQS ì´ë²¤íŠ¸ ì „ì†¡ ì‹¤íŒ¨", error);
  }

  // 3. WebP ë³€í™˜ ìˆ˜í–‰ í›„ ê²°ê³¼ ë°˜í™˜
  const originalBuffer = await getFileAsBuffer(bucket, key);
  if (originalBuffer instanceof Error) {
    callback(null, response);
    return;
  }

  try {
    const webpBase64 = await convertToWebPAndBase64(originalBuffer, w, h);
    response.headers["content-type"] = [
      { key: "Content-Type", value: "image/webp" }
    ];
    response.headers["cache-control"] = [
      { key: "Cache-Control", value: "public, max-age=86400" }
    ];
    callback(null, {
      ...response,
      body: webpBase64,
      bodyEncoding: "base64"
    });
  } catch (error) {
    console.error("WebP ë³€í™˜ ì‹¤íŒ¨", error);
    callback(null, response);
  }
}
```

---

## ê²°ê³¼ ë° ê°œì„  íš¨ê³¼

### ì„±ëŠ¥ ê°œì„ 

| ì§€í‘œ | ê°œì„  ì „ | ê°œì„  í›„ |
|------|---------|---------|
| ì²« ìš”ì²­ ì‘ë‹µ ì‹œê°„ | 20ì´ˆ+ | 1-2ì´ˆ |
| AVIF ì œê³µë¥  | 0% | ì ì§„ì  ì¦ê°€ |
| ì‚¬ìš©ì ì²´ê° ì†ë„ | ë§¤ìš° ëŠë¦¼ | ë¹ ë¦„ |

### ì£¼ìš” ê°œì„  ì‚¬í•­

1. âœ… **ì¦‰ì‹œ ì‘ë‹µ**: ì²« ìš”ì²­ ì‹œ WebPë¡œ ë¹ ë¥´ê²Œ ì œê³µ
2. âœ… **ì ì§„ì  ìµœì í™”**: ë°±ê·¸ë¼ìš´ë“œì—ì„œ AVIF ë³€í™˜ í›„ ì´í›„ ìš”ì²­ì— ì œê³µ
3. âœ… **ë¹„ìš© íš¨ìœ¨**: Lambda ì‹¤í–‰ ì‹œê°„ ëŒ€í­ ê°ì†Œ
4. âœ… **ì‚¬ìš©ì ê²½í—˜**: ì´ë¯¸ì§€ ë¡œë”© ì§€ì—° ì—†ìŒ

---

## ê²°ë¡ 

Lambda@Edgeë¥¼ í™œìš©í•œ ì´ë¯¸ì§€ ìµœì í™” ê³¼ì •ì—ì„œ AVIF ë³€í™˜ì˜ ì„±ëŠ¥ ë¬¸ì œë¥¼ **SQS ê¸°ë°˜ ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬**ë¡œ í•´ê²°í–ˆìŠµë‹ˆë‹¤.

### í•µì‹¬ êµí›ˆ

- ğŸ¯ **ë¬´ê±°ìš´ ì‘ì—…ì€ ë¹„ë™ê¸°ë¡œ**: ì‹¤ì‹œê°„ ì‘ë‹µì´ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸ì—ì„œ ë¬´ê±°ìš´ ì‘ì—…ì€ ë°±ê·¸ë¼ìš´ë“œë¡œ
- ğŸ¯ **ì ì§„ì  ìµœì í™”**: ì²« ìš”ì²­ì€ ë¹ ë¥´ê²Œ, ì´í›„ ì ì§„ì ìœ¼ë¡œ ê°œì„ 
- ğŸ¯ **ì ì ˆí•œ ë„êµ¬ ì„ íƒ**: SQS + Lambda ì¡°í•©ìœ¼ë¡œ ì´ë²¤íŠ¸ ê¸°ë°˜ ì•„í‚¤í…ì²˜ êµ¬í˜„

ì´ëŸ¬í•œ ì ‘ê·¼ ë°©ì‹ì€ ë‹¤ë¥¸ ë¬´ê±°ìš´ ë³€í™˜ ì‘ì—…ì—ë„ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
