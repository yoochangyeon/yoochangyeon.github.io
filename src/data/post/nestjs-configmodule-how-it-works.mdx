---
publishDate: 2025-01-15T09:00:00Z
updateDate: 2025-01-15T09:00:00Z
author: "유창연"
title: "NestJS ConfigModule 동작 원리 완벽 가이드: ConfigService 값 조회 실패 해결"
excerpt: "ConfigService에서 환경변수가 조회되지 않는 문제의 근본 원인을 코드 레벨에서 분석합니다. DynamicModule 생성 과정과 Provider 주입 메커니즘을 상세히 파헤쳐 실전 해결 방법을 제시합니다."
description: "NestJS ConfigModule의 DynamicModule 생성 과정과 Provider 주입 메커니즘을 소스 코드 레벨에서 분석합니다. ConfigService에서 환경변수가 조회되지 않는 문제의 근본 원인과 올바른 해결 방법을 실전 경험을 바탕으로 상세히 설명합니다."
# TODO: 이미지 최적화 권장사항
# 1. Unsplash 이미지를 다운로드하여 /public/images/blog/ 에 저장
# 2. WebP 포맷으로 변환
# 3. 파일명: nestjs-configmodule-guide.webp
# 4. image 속성을 "/images/blog/nestjs-configmodule-guide.webp"로 변경
image: "https://images.unsplash.com/photo-1555066931-4365d14bab8c?w=1200&h=630&fit=crop"
imageAlt: "NestJS 프레임워크 코드 구조 - ConfigModule과 DynamicModule 아키텍처 다이어그램"
category: "NestJS"
tags: ["nestjs", "config", "backend", "troubleshooting", "dependency-injection"]
keywords: ["NestJS ConfigModule", "ConfigService 값 조회 안됨", "NestJS 환경변수 설정", "DynamicModule 동작 원리", "Provider 주입 메커니즘", "NestJS forRoot", "Dependency Injection", "AWS Secrets Manager", "NestJS 문제 해결", "isGlobal true"]
draft: false
---

## 문제 상황

### ConfigService에서 값이 불러와지지 않는다?

타임스프레드에서는 AWS Secrets Manager를 통해 가져온 값을 NestJS의 `ConfigService`에 등록해두고 사용하고 싶었습니다. 이를 위해 다음과 같은 작업을 진행했습니다.

### 1. AppModule에서 ConfigModule 등록

`AppModule`에서 `ConfigModule`을 등록할 때, `load`를 통해 환경변수를 설정했습니다. (`getSecretValue`는 AWS Secrets Manager를 통해 값을 가져오는 함수입니다)

```typescript
@Module({
  imports: [
    ConfigModule.forRoot({
      ignoreEnvFile: true,
      isGlobal: true,
      cache: true,
      validationSchema: Joi.object({
        NODE_ENV: Joi.string()
          .valid('dev', 'ci', 'test', 'qa', 'production')
          .required(),
        DATABASE_URL: Joi.string().required(),
        REDIS_URL: Joi.string().required(),
        PORT: Joi.number().default(3000),
      }),
      validationOptions: {
        allowUnknown: false,
        abortEarly: true,
      },
      load: [getSecretValue],
    }),
    // ... 기타 모듈들
  ],
})
export class AppModule {}
```

### 2. AuthModule에 ConfigModule 추가

`AppleStrategy`를 provide하고 있는 `AuthModule`에 `ConfigModule`을 추가했습니다.

```typescript
@Module({
  imports: [
    forwardRef(() => UserModule),
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET,
    }),
    ConfigModule, // ConfigModule 추가
    RouletteModule,
  ],
  controllers: [AuthController],
  providers: [
    AuthService,
    KakaoStrategy,
    FacebookStrategy,
    NaverStrategy,
    AppleStrategy,
    EmailStrategy,
  ],
  exports: [AuthService],
})
export class AuthModule {}
```

### 3. AppleStrategy에서 ConfigService 사용

`AppleStrategy`에서 `ConfigService`를 주입받아 사용했습니다.

```typescript
@Injectable()
export class AppleStrategy extends PassportStrategy(Strategy, 'apple') {
  private static readonly JWKS = createRemoteJWKSet(
    new URL('https://appleid.apple.com/auth/keys'),
  );

  constructor(configService: ConfigService) {
    const clientId = configService.get<string>('APPLE_CLIENT_ID');
    const teamId = configService.get<string>('APPLE_TEAM_ID');
    const keyId = configService.get<string>('APPLE_KEY_ID');
    const redirectUrl = configService.get<string>('APPLE_REDIRECT_URL');
    const decodedBuffer = Buffer.from(
      configService.get<string>('APPLE_PRIVATE_KEY'),
      'base64',
    );
    const privateKey = decodedBuffer.toString('utf-8');

    super(
      {
        clientID: clientId,
        teamID: teamId,
        keyID: keyId,
        callbackURL: redirectUrl,
        privateKeyString: privateKey,
      },
      AppleStrategy.verify,
    );
  }
  // ...
}
```

### 문제 발생

이렇게 작업했을 때 다음 값들을 제대로 가져오지 못했습니다:

```typescript
const clientId = configService.get<string>('APPLE_CLIENT_ID');
const teamId = configService.get<string>('APPLE_TEAM_ID');
const keyId = configService.get<string>('APPLE_KEY_ID');
const redirectUrl = configService.get<string>('APPLE_REDIRECT_URL');
```

---

## 시도한 해결 방법

이를 해결하기 위해 `AuthModule`에서 `ConfigModule`을 제거해봤습니다.

```typescript
@Module({
  imports: [
    forwardRef(() => UserModule),
    JwtModule.register({
      global: true,
      secret: process.env.JWT_SECRET,
    }),
    // ConfigModule 제거!
    RouletteModule,
  ],
  // ...
})
export class AuthModule {}
```

**놀랍게도 문제가 해결되었습니다!** `AuthModule`에서 `ConfigModule`을 import하지 않게 바꾸니 정상적으로 동작했습니다.

---

## 의문점

문제는 해결되었지만, 의문이 생겼습니다.

NestJS 공식 문서에서는 분명히 다음과 같이 설명하고 있습니다:

> `ConfigModule.forRoot()`에서 `isGlobal: true`인 경우, 다른 모듈에서 import하지 않고도 `ConfigService`를 사용할 수 있다.

하지만 "다른 모듈에서 `ConfigModule`을 import하면 안 된다"라고는 나와있지 않습니다.

**그렇다면 `ConfigModule`을 import했을 때와 하지 않았을 때, 왜 다르게 동작하는 걸까요?**

---

## 원인 파악

`ConfigModule`의 import 유무에 따라 다르게 동작하는 원인을 파악하기 위해서는 NestJS의 ConfigModule이 어떻게 만들어져 있는지 확인해야 합니다.

### ConfigModule.forRoot()가 반환하는 DynamicModule

[ConfigModule 소스코드](https://github.com/nestjs/config/blob/master/lib/config.module.ts)를 살펴보면, `forRoot()`는 `DynamicModule`을 반환합니다.

```typescript
return {
  module: ConfigModule,
  global: options.isGlobal,
  providers: isConfigToLoad
    ? [
        ...providers,
        {
          provide: CONFIGURATION_LOADER,
          useFactory: (
            host: Record<string, any>,
            ...configurations: Record<string, any>[]
          ) => {
            configurations.forEach((item, index) =>
              this.mergePartial(host, item, providers[index]),
            );
          },
          inject: [CONFIGURATION_TOKEN, ...configProviderTokens],
        },
      ]
    : providers,
  exports: [ConfigService, ...configProviderTokens],
};
```

반환되고 있는 것은 크게 두 가지입니다:

1. **어딘가에서 만들어졌을 `providers`**
2. **`CONFIGURATION_LOADER`를 토큰으로 한 provider**

이 두 가지를 순서대로 살펴봅시다.

---

## Providers의 구성

### 1. providers 생성 과정

```typescript
const providers = (options.load || [])
  .map(factory =>
    createConfigProvider(factory as ConfigFactory & ConfigFactoryKeyHost),
  )
  .filter(item => item) as FactoryProvider[];
```

- **`options.load`가 없는 경우** → 빈 리스트
- **`options.load`가 있는 경우** → `load`에 들어간 객체를 `FactoryProvider`로 변환해서 모아둔 리스트

`createConfigProvider` 함수를 확인하면, `load`에 들어간 function이 `useFactory`에 들어가는 것을 확인할 수 있습니다.

### 2. Provider 토큰 목록 생성

만들어진 provider에서 `provide` 토큰만 가져와 토큰 목록을 만듭니다:

```typescript
const configProviderTokens = providers.map(item => item.provide);
```

### 3. ConfigService Provider 생성

```typescript
const configServiceProvider = {
  provide: ConfigService,
  useFactory: (configService: ConfigService) => {
    if (options.cache) {
      (configService as any).isCacheEnabled = true;
    }
    configService.setEnvFilePaths(envFilePaths);
    return configService;
  },
  inject: [CONFIGURATION_SERVICE_TOKEN, ...configProviderTokens],
};

providers.push(configServiceProvider);
```

Factory를 사용해서 새로운 `ConfigService`를 반환합니다. 여기서 주입되는 `configService`는 `CONFIGURATION_SERVICE_TOKEN` 토큰으로 가져오며, 이는 `ConfigHostModule`에서 제공합니다.

### 4. ConfigHostModule

```typescript
@Global()
@Module({
  providers: [
    {
      provide: CONFIGURATION_TOKEN,
      useFactory: () => ({}),
    },
    {
      provide: CONFIGURATION_SERVICE_TOKEN,
      useClass: ConfigService,
    },
  ],
  exports: [CONFIGURATION_TOKEN, CONFIGURATION_SERVICE_TOKEN],
})
export class ConfigHostModule {}
```

`ConfigHostModule`은 Global 모듈로 되어있어서 import하지 않고도 inject할 수 있습니다.

### Providers 최종 구성

**load가 있는 경우:**
1. load 내부 함수를 factory로 하는 provider 리스트
2. ConfigService를 provide하는 provider

**load가 없는 경우:**
- ConfigService를 provide하는 provider

---

## CONFIGURATION_LOADER의 역할

```typescript
const isConfigToLoad = options.load && options.load.length;

return {
  module: ConfigModule,
  global: options.isGlobal,
  providers: isConfigToLoad
    ? [
        ...providers,
        {
          provide: CONFIGURATION_LOADER,
          useFactory: (
            host: Record<string, any>,
            ...configurations: Record<string, any>[]
          ) => {
            configurations.forEach((item, index) =>
              this.mergePartial(host, item, providers[index]),
            );
          },
          inject: [CONFIGURATION_TOKEN, ...configProviderTokens],
        },
      ]
    : providers,
  exports: [ConfigService, ...configProviderTokens],
};
```

`load`가 있는 경우, `CONFIGURATION_LOADER`를 토큰으로 하는 provider가 추가됩니다. 이 provider는 `CONFIGURATION_TOKEN`으로 주입된 `host`에 나머지 환경변수들을 넣어줍니다.

### ConfigService의 get() 메서드

우리는 보통 환경 변수를 가져올 때 `configService.get('something')`을 사용합니다:

```typescript
get<T = any>(
  propertyPath: KeyOf<K>,
  defaultValueOrOptions?: T | ConfigGetOptions,
  options?: ConfigGetOptions,
): T | undefined {
  const validatedEnvValue = this.getFromValidatedEnv(propertyPath);
  if (!isUndefined(validatedEnvValue)) {
    return validatedEnvValue;
  }

  const processEnvValue = this.getFromProcessEnv(propertyPath, defaultValue);
  if (!isUndefined(processEnvValue)) {
    return processEnvValue;
  }

  const internalValue = this.getFromInternalConfig(propertyPath);
  if (!isUndefined(internalValue)) {
    return internalValue;
  }

  return defaultValue as T;
}
```

값을 찾는 순서:
1. `validatedEnvValue`
2. `processEnvValue`
3. `internalValue`

### getFromInternalConfig

```typescript
private getFromInternalConfig<T = any>(
  propertyPath: KeyOf<K>,
): T | undefined {
  const internalValue = get(this.internalConfig, propertyPath);
  return internalValue;
}
```

`this.internalConfig`에서 값을 찾아옵니다. 이 `internalConfig`는 `ConfigService` 생성 시 주입됩니다:

```typescript
constructor(
  @Optional()
  @Inject(CONFIGURATION_TOKEN)
  private readonly internalConfig: Record<string, any> = {},
) {}
```

**즉, `internalValue`에 값을 추가해주기 위해서는 `ConfigHostModule`에서 `CONFIGURATION_TOKEN` 토큰으로 제공하는 `{}` 객체에 값을 추가해주는 과정이 필요합니다.**

### DynamicModule 최종 정리

이제 `forRoot`의 결과물을 완전히 이해할 수 있습니다:

**load가 있는 경우:**
1. ConfigService를 provide하는 provider
2. load 내부 함수를 factory로 하는 provider 리스트 → 이를 통해 ConfigService의 InternalValue 값 등록

**load가 없는 경우:**
- ConfigService를 provide하는 provider

그리고 `global` 옵션에 따라 이 DynamicModule을 Global 모듈로 등록할 수 있습니다.

---

## 왜 만들어진 DynamicModule을 쓰지 못했는가?

### 문제의 핵심: 비동기 모듈 초기화

타임스프레드에서는 `main.ts`에서 `AppModule`을 가지고 NestJS 서버를 실행시킵니다:

```typescript
const server = await NestFactory.create<NestExpressApplication>(AppModule, {
  bodyParser: false,
  logger: logger,
});
```

`AppModule`에는 `ConfigModule`을 제외하고도 수많은 모듈을 import합니다:

```typescript
@Module({
  imports: [
    ConfigModule.forRoot({
      // ... 설정
      load: [getSecretValue],
    }),
    RepoModule,
    CacheDBModule,
    NewsModule,
    // ... 많은 모듈들
    BaseControllersModule,
  ],
  controllers: [ProxyController],
})
export class AppModule implements NestModule {}
```

**중요한 점: 모듈이 import되는 순서는 보장되지 않습니다. 비동기로 처리됩니다.**

### 잘못된 ConfigService 주입

최초 문제가 발생했던 `AuthModule`도 `ConfigModule`과 동시에 비동기로 만들어집니다.

**`AuthModule`에서 `ConfigModule`을 import하면:**
- `ConfigModule.forRoot()`의 결과물(DynamicModule)을 import하는 것이 **아니라**
- `ConfigModule`이 기본적으로 제공하는 다음 형태가 import됩니다:

```typescript
@Module({
  imports: [ConfigHostModule],
  providers: [
    {
      provide: ConfigService,
      useExisting: CONFIGURATION_SERVICE_TOKEN,
    },
  ],
  exports: [ConfigHostModule, ConfigService],
})
export class ConfigModule {
  // ...
}
```

이 모듈을 통해 제공되는 `ConfigService`는 `ConfigHostModule`이 제공하는 `ConfigService`이고, 이는 **factory 패턴으로 만들어지지 않았기 때문에 `internalConfig`가 비어있습니다(`{}`)**.

### 결론

`ConfigModule`과 동시에 만들어지는 다른 모듈들에서 `ConfigModule`을 import하고 `ConfigService`를 주입받으려 한다면:

- ❌ **잘못된 주입**: `ConfigHostModule`이 제공하는 빈 `ConfigService`
- ✅ **올바른 주입**: `forRoot()`를 통해 만들어진 DynamicModule이 제공하는 `ConfigService`

그래서 `configService.get()`으로 환경 변수를 얻으려 할 때:
- Beanstalk 환경변수는 가져와졌지만
- **`load`에 넣어둔 값은 사용할 수 없었던 것입니다**

---

## 해결 방법

`ConfigModule.forRoot()`에서 `isGlobal: true`로 설정했다면:
- **다른 모듈에서 `ConfigModule`을 import하지 마세요**
- Global 모듈로 등록된 `ConfigService`를 바로 주입받아 사용하세요

```typescript
// ❌ 잘못된 방법
@Module({
  imports: [ConfigModule], // 불필요!
  providers: [AppleStrategy],
})
export class AuthModule {}

// ✅ 올바른 방법
@Module({
  imports: [], // ConfigModule import 없이
  providers: [AppleStrategy], // ConfigService 바로 주입 가능
})
export class AuthModule {}
```
