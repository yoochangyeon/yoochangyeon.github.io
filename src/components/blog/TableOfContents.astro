---
export interface Props {
  headings: { depth: number; slug: string; text: string }[];
}

const { headings } = Astro.props;

// Filter to only show h2 and h3 headings
const filteredHeadings = headings.filter((h) => h.depth >= 2 && h.depth <= 3);
---

{
  filteredHeadings.length > 0 && (
    <aside class="toc-container hidden xl:block">
      <nav class="toc-nav">
        <h2 class="toc-title">목차</h2>
        <ul class="toc-list">
          {filteredHeadings.map((heading) => (
            <li class={`toc-item toc-depth-${heading.depth}`}>
              <a href={`#${heading.slug}`} class="toc-link" data-heading={heading.slug}>
                {heading.text}
              </a>
            </li>
          ))}
        </ul>
      </nav>
    </aside>
  )
}

<style>
  .toc-container {
    position: fixed;
    top: 120px;
    right: max(1rem, calc((100% - 768px) / 2 - 250px - 2rem));
    width: 250px;
    max-height: 50vh;
    overflow-y: auto;
    overflow-x: hidden;
  }

  @media (min-width: 1536px) {
    .toc-container {
      right: max(1.5rem, calc((100% - 768px) / 2 - 280px - 2rem));
      width: 280px;
    }
  }

  .toc-nav {
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: 0.5rem;
    padding: 1.25rem;
    backdrop-filter: blur(10px);
    margin-right: 0.5rem;
  }

  :global(.dark) .toc-nav {
    background: rgba(23, 23, 23, 0.8);
    border-color: rgba(255, 255, 255, 0.1);
  }

  .toc-title {
    font-size: 0.875rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 1rem;
    color: rgb(75, 85, 99);
  }

  :global(.dark) .toc-title {
    color: rgb(209, 213, 219);
  }

  .toc-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .toc-item {
    margin: 0;
    padding: 0;
  }

  .toc-link {
    display: block;
    padding: 0.375rem 0;
    font-size: 0.875rem;
    line-height: 1.5;
    color: rgb(107, 114, 128);
    text-decoration: none;
    transition: all 0.2s ease;
    border-left: 2px solid transparent;
    padding-left: 0.75rem;
  }

  .toc-depth-3 .toc-link {
    padding-left: 1.5rem;
    font-size: 0.8125rem;
  }

  .toc-link:hover {
    color: rgb(59, 130, 246);
    border-left-color: rgb(59, 130, 246);
  }

  :global(.dark) .toc-link {
    color: rgb(156, 163, 175);
  }

  :global(.dark) .toc-link:hover {
    color: rgb(96, 165, 250);
    border-left-color: rgb(96, 165, 250);
  }

  .toc-link.active {
    color: rgb(37, 99, 235);
    font-weight: 700;
    border-left-color: rgb(37, 99, 235);
  }

  :global(.dark) .toc-link.active {
    color: rgb(147, 197, 253);
    border-left-color: rgb(147, 197, 253);
  }

  /* Custom scrollbar - 컨테이너 오른쪽에 붙은 스타일 */
  .toc-container {
    scrollbar-width: thin;
    scrollbar-color: rgb(209, 213, 219) transparent;
  }

  :global(.dark) .toc-container {
    scrollbar-color: rgb(75, 85, 99) transparent;
  }

  /* Webkit browsers (Chrome, Safari, Edge) */
  .toc-container::-webkit-scrollbar {
    width: 2px;
  }

  .toc-container::-webkit-scrollbar-track {
    background: transparent;
    margin: 0.25rem 0;
  }

  .toc-container::-webkit-scrollbar-thumb {
    background: rgb(209, 213, 219);
    border-radius: 2px;
  }

  .toc-container::-webkit-scrollbar-thumb:hover {
    background: rgb(156, 163, 175);
  }

  :global(.dark) .toc-container::-webkit-scrollbar-thumb {
    background: rgb(75, 85, 99);
  }

  :global(.dark) .toc-container::-webkit-scrollbar-thumb:hover {
    background: rgb(107, 114, 128);
  }
</style>

<script>
  // Scroll spy functionality using Intersection Observer
  function initScrollSpy() {
    const tocLinks = document.querySelectorAll('.toc-link');
    const headings = document.querySelectorAll(
      '.prose h2[id], .prose h3[id]'
    );

    if (tocLinks.length === 0 || headings.length === 0) return;

    // Create a map of heading IDs to TOC links
    const headingMap = new Map<Element, Element>();
    headings.forEach((heading) => {
      const id = heading.getAttribute('id');
      if (id) {
        const link = document.querySelector(`.toc-link[data-heading="${id}"]`);
        if (link) {
          headingMap.set(heading, link);
        }
      }
    });

    // Set up Intersection Observer
    const observerOptions = {
      root: null,
      rootMargin: '-80px 0px -80% 0px', // Trigger when heading is near top
      threshold: 0,
    };

    let activeHeading: Element | null = null;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        const link = headingMap.get(entry.target);
        if (!link) return;

        if (entry.isIntersecting) {
          // Remove active class from all links
          tocLinks.forEach((l) => l.classList.remove('active'));

          // Add active class to current link
          link.classList.add('active');
          activeHeading = entry.target;

          // Scroll TOC to show active link
          const tocContainer = document.querySelector('.toc-container');
          if (tocContainer && link) {
            const linkElement = link as HTMLElement;
            const containerElement = tocContainer as HTMLElement;
            const linkTop = linkElement.offsetTop;
            const containerHeight = containerElement.clientHeight;
            const scrollTarget = linkTop - containerHeight / 2;

            containerElement.scrollTo({
              top: scrollTarget,
              behavior: 'smooth',
            });
          }
        }
      });
    }, observerOptions);

    // Observe all headings
    headings.forEach((heading) => observer.observe(heading));

    // Smooth scroll on link click
    tocLinks.forEach((link) => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const href = link.getAttribute('href');
        if (href) {
          const targetId = href.slice(1);
          const targetElement = document.getElementById(targetId);
          if (targetElement) {
            const headerOffset = 80;
            const elementPosition = targetElement.getBoundingClientRect().top;
            const offsetPosition = elementPosition + window.scrollY - headerOffset;

            window.scrollTo({
              top: offsetPosition,
              behavior: 'smooth',
            });
          }
        }
      });
    });
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', initScrollSpy);

  // Re-initialize after Astro page transitions (if using View Transitions)
  document.addEventListener('astro:after-swap', initScrollSpy);
</script>
